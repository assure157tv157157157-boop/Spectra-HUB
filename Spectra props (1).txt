--// SERVICES
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local plr = Players.LocalPlayer
local character = plr.Character or plr.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

plr.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")
end)

--// UI LIB
local Library = loadstring(game:HttpGet("https://pastefy.app/MaVJLHB7/raw"))()

local Window = Library:MakeWindow({
    Title = "spectra props",
    SubTitle = "by: assure_TV",
    LoadText = "Carregando Spectra",
    Flags = "Spectrahub_Brookhaven",

    Size = UDim2.new(0, 400, 0, 400) -- TAMANHO FIXO (largura 600, altura 350)
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://123419106595949", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(35, 1) }
})




--////////////////////////////////////////////////////
--// TROLL TAB
local TrollTab = Window:MakeTab({
    Title = "props",
    Icon = "rbxassetid://105645877854135"
})

--////////////////////////////////////////////////////
--// PLAYER LIST
local selectedPlayer

local function getPlayers()
    local t = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= plr then
            table.insert(t, p.Name)
        end
    end
    return t
end

local dropdown = TrollTab:AddDropdown({
    Name = "Escolher Player",
    Options = getPlayers(),
    Callback = function(v)
        selectedPlayer = v
    end
})

TrollTab:AddButton({
    Name = "Atualizar Lista",
    Callback = function()
        dropdown:Set(getPlayers())
    end
})





--==============================
-- SPECTATE (BOTÃO ARRUMADO)
--==============================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local spectating = false
local spectateConn
local charConn
local currentTarget

--==============================
-- FUNÇÕES
--==============================
local function resetCamera()
if spectateConn then spectateConn:Disconnect() spectateConn = nil end
if charConn then charConn:Disconnect() charConn = nil end

currentTarget = nil

local char = LocalPlayer.Character
local hum = char and char:FindFirstChildOfClass("Humanoid")
if hum then
Camera.CameraSubject = hum
Camera.CameraType = Enum.CameraType.Custom
end

end

local function spectatePlayer(player)
if not spectating or not player then return end

resetCamera()
spectating = true
currentTarget = player

spectateConn = RunService.RenderStepped:Connect(function()
if not spectating then return end
if not currentTarget or not currentTarget.Character then return end

local hum = currentTarget.Character:FindFirstChildOfClass("Humanoid")
if hum then
Camera.CameraSubject = hum
Camera.CameraType = Enum.CameraType.Custom
end

end)

charConn = player.CharacterAdded:Connect(function()
task.wait(0.1)
if spectating and currentTarget == player then
spectatePlayer(player)
end
end)

end

--==============================
-- PLAYER SAINDO
--==============================
Players.PlayerRemoving:Connect(function(plr)
if spectating and currentTarget == plr then
resetCamera()
spectating = false
end
end)

--==============================
-- BOTÃO
--==============================
TrollTab:AddToggle({
Name = "Spectar Jogador",
Default = false,
Callback = function(state)
spectating = state

if not state then
resetCamera()
return
end

local target = Players:FindFirstChild(selectedPlayer)
if target then
spectatePlayer(target)
else
resetCamera()
end

end

})



--////////////////////////////////////////////////////
--// ANTI-SIT
TrollTab:AddSection({ "Anti-Sit" })

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local antiSitEnabled = false
local antiSitConn

TrollTab:AddToggle({
    Name = "Anti-Sit",
    Default = false,
    Callback = function(state)
        antiSitEnabled = state

        local function apply(character)
            local hum = character:FindFirstChildOfClass("Humanoid")
            if not hum then return end

            hum.Sit = false
            hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

            if antiSitConn then
                antiSitConn:Disconnect()
            end

            antiSitConn = hum.Seated:Connect(function(sit)
                if sit then
                    hum.Sit = false
                    hum:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end)
        end

        if state then
            if LocalPlayer.Character then
                apply(LocalPlayer.Character)
            end

            LocalPlayer.CharacterAdded:Connect(function(char)
                if antiSitEnabled then
                    apply(char)
                end
            end)
        else
            if antiSitConn then
                antiSitConn:Disconnect()
                antiSitConn = nil
            end

            if LocalPlayer.Character then
                local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
                end
            end
        end
    end
})


TrollTab:AddSection({"props all"})


--===============================
-- PROP RAID (troll prop all)
--===============================

local PROP_RAID_ENABLED = false
local PROP_RAID_CONNECTION
local PROP_RAID_Targets = {}

local function UpdateRaidCharacter(char)
Character = char
HRP = char:WaitForChild("HumanoidRootPart", 5)
Humanoid = char:WaitForChild("Humanoid", 5)
end

if LocalPlayer.Character then
UpdateRaidCharacter(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(function(char)
StopPropRaid()
task.wait(0.5)
UpdateRaidCharacter(char)
if PROP_RAID_ENABLED then
task.wait(0.5)
StartPropRaid()
end
end)

pcall(function()
ReplicatedStorage.RE["1Too1l"]:InvokeServer("PickingTools", "PropMaker")
end)

task.wait(0.3)

pcall(function()
ReplicatedStorage.RE["1Clea1rTool1s"]:FireServer(
"RequestingPropName",
"FurnitureBleachers",
"Furniture"
)
end)

local propCache = {}
local lastUpdate = 0

local function GetMyPropsRaid()
if tick() - lastUpdate < 0.4 then return propCache end

propCache = {}
local ws = workspace:FindFirstChild("WorkspaceCom")
if not ws then return propCache end

for _, folder in ipairs(ws:GetChildren()) do
    for _, prop in ipairs(folder:GetChildren()) do
        if prop:FindFirstChild("SetCurrentCFrame")
        and prop.Name:lower():find(LocalPlayer.Name:lower()) then
            table.insert(propCache, prop)
        end
    end
end

lastUpdate = tick()
return propCache

end

local function GetTargetsRaid()
local t = {}
if not HRP then return t end

for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer
    and plr.Character
    and plr.Character:FindFirstChild("HumanoidRootPart") then
        local dist = (plr.Character.HumanoidRootPart.Position - HRP.Position).Magnitude
        if dist <= 222 then
            table.insert(t, plr)
        end
    end
end
return t

end

local function AssignTargetsRaid(props, targets)
if #targets == 0 then return end
for i, prop in ipairs(props) do
local index = ((i - 1) % #targets) + 1
PROP_RAID_Targets[prop] = targets[index]
end
end

local function GetNextTargetRaid(targets, current)
if #targets == 0 then return nil end
for i, plr in ipairs(targets) do
if plr == current then
return targets[(i % #targets) + 1]
end
end
return targets[1]
end

local angle = 0
local height = 0
local dir = 1

function StartPropRaid()
if PROP_RAID_CONNECTION then PROP_RAID_CONNECTION:Disconnect() end

PROP_RAID_CONNECTION = RunService.Heartbeat:Connect(function()
    if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

    local props = GetMyPropsRaid()
    local targets = GetTargetsRaid()
    if #props == 0 or #targets == 0 then return end

    AssignTargetsRaid(props, targets)

    angle += math.rad(20)
    if height > 4 then dir = -1 end
    if height < -4 then dir = 1 end
    height += 0.3 * dir

    for _, prop in ipairs(props) do
        local target = PROP_RAID_Targets[prop]
        if not target or not target.Character then
            PROP_RAID_Targets[prop] = GetNextTargetRaid(targets, target)
            continue
        end

        local hum = target.Character:FindFirstChild("Humanoid")
        local root = target.Character:FindFirstChild("HumanoidRootPart")
        if not hum or not root then continue end

        if hum.Sit then
            PROP_RAID_Targets[prop] = GetNextTargetRaid(targets, target)
            continue
        end

        local radius = math.random(2,5)
        local offset = Vector3.new(math.cos(angle)*radius,height,math.sin(angle)*radius)

        pcall(function()
            prop.SetCurrentCFrame:InvokeServer(
                root.CFrame * CFrame.new(offset)
            )
        end)
    end
end)

end

function StopPropRaid()
if PROP_RAID_CONNECTION then
PROP_RAID_CONNECTION:Disconnect()
PROP_RAID_CONNECTION = nil
end
PROP_RAID_Targets = {}
end

TrollTab:AddToggle({
Name = "próp sit all",
Default = false,
Callback = function(v)
PROP_RAID_ENABLED = v
if v then
StartPropRaid()
else
StopPropRaid()
end
end
})




--===============================
-- PROPS CAÃ‡ADORES INTELIGENTES
--===============================

local HUNT_ENABLED = false
local HUNT_CONNECTION
local TARGET_RADIUS = 150
local MAX_PROPS_PER_PLAYER = 3

local PropTargetMap = {}
local DroppedProps = {}

local function GetNearbyPlayers()
    local list = {}
    if not HRP then return list end

    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer
        and p.Character
        and p.Character:FindFirstChild("HumanoidRootPart")
        and p.Character:FindFirstChild("Humanoid")
        and p.Character.Humanoid.Health > 0 then

            local dist = (p.Character.HumanoidRootPart.Position - HRP.Position).Magnitude
            if dist <= TARGET_RADIUS then
                table.insert(list, p)
            end
        end
    end

    return list
end

local function CountPropsOnPlayer(player)
    local count = 0
    for _,target in pairs(PropTargetMap) do
        if target == player then
            count += 1
        end
    end
    return count
end

local function GetBestTarget(targets)
    local bestPlayer = nil
    local lowestCount = math.huge

    for _,plr in ipairs(targets) do
        local c = CountPropsOnPlayer(plr)
        if c < lowestCount and c < MAX_PROPS_PER_PLAYER then
            lowestCount = c
            bestPlayer = plr
        end
    end

    return bestPlayer
end

local function StartHunter()
    if HUNT_CONNECTION then HUNT_CONNECTION:Disconnect() end

    local t = 0

    HUNT_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end
        t += dt

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        local targets = GetNearbyPlayers()

        for i, prop in ipairs(props) do
            local currentTarget = PropTargetMap[prop]

            -- verifica se alvo saiu da Ã¡rea ou morreu
            if currentTarget then
                local char = currentTarget.Character
                if not char
                or not char:FindFirstChild("HumanoidRootPart")
                or not char:FindFirstChild("Humanoid")
                or char.Humanoid.Health <= 0
                or (char.HumanoidRootPart.Position - HRP.Position).Magnitude > TARGET_RADIUS then
                    PropTargetMap[prop] = nil
                    currentTarget = nil
                end
            end

            -- escolhe novo alvo inteligente
            if not currentTarget then
                local newTarget = GetBestTarget(targets)
                PropTargetMap[prop] = newTarget
                currentTarget = newTarget
            end

            -- sem ninguÃ©m perto â†’ volta pra vocÃª
            if not currentTarget then
                local offset = Vector3.new(
                    math.cos(i+t)*4,
                    2 + math.sin(t*2+i),
                    math.sin(i+t)*4
                )

                local cf = CFrame.new(HRP.Position + offset)

                pcall(function()
                    prop.SetCurrentCFrame:InvokeServer(
                        prop:GetPivot():Lerp(cf, 0.3)
                    )
                end)

                continue
            end

            local hum = currentTarget.Character:FindFirstChild("Humanoid")
            local root = currentTarget.Character:FindFirstChild("HumanoidRootPart")
            if not hum or not root then continue end

            -- sentou â†’ joga pra baixo
            if hum.Sit then
                if not DroppedProps[prop] then
                    DroppedProps[prop] = true

                    local dropPos = Vector3.new(
                        root.Position.X,
                        -460,
                        root.Position.Z
                    )

                    pcall(function()
                        prop.SetCurrentCFrame:InvokeServer(CFrame.new(dropPos))
                    end)
                end
                continue
            end

            -- levantou â†’ volta pro sistema
            if DroppedProps[prop] and not hum.Sit then
                DroppedProps[prop] = nil
            end

            -- movimento inteligente perto do player (baixo + mexendo)
            local move = Vector3.new(
                math.cos(t*3 + i) * 2,
                -1.5 + math.sin(t*4 + i),
                math.sin(t*3 + i) * 2
            )

            local cf = root.CFrame * CFrame.new(move) *
                CFrame.Angles(
                    math.rad(math.sin(t*5+i)*120),
                    math.rad(t*180),
                    0
                )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.35)
                )
            end)
        end
    end)
end

local function StopHunter()
    if HUNT_CONNECTION then
        HUNT_CONNECTION:Disconnect()
        HUNT_CONNECTION = nil
    end
    PropTargetMap = {}
    DroppedProps = {}
end

TrollTab:AddToggle({
    Name = "prop kill all",
    Default = false,
    Callback = function(v)
        HUNT_ENABLED = v
        if v then
            StartHunter()
        else
            StopHunter()
        end
    end
})



TrollTab:AddSection({"props para usar em mim"})

--===============================
-- PROP COBRA
--===============================

local COBRA_ENABLED = false
local COBRA_CONNECTION

local FOLLOW_DISTANCE = 3.5
local SIDE_AMPLITUDE = 3.2
local UP_AMPLITUDE = 1.2
local WAVE_SPEED = 10
local PHASE_OFFSET = 1.1
local SMOOTHNESS = 0.35

function StartCobra()
if COBRA_CONNECTION then COBRA_CONNECTION:Disconnect() end
local time = 0

COBRA_CONNECTION = RunService.Heartbeat:Connect(function(dt)
    if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

    local props = GetMyPropsRaid()
    if #props == 0 then return end

    time += dt * WAVE_SPEED

    for i, prop in ipairs(props) do
        local phase = time - i * PHASE_OFFSET

        local backDir = -HRP.CFrame.LookVector
        local rightDir = HRP.CFrame.RightVector
        local upDir = Vector3.new(0,1,0)

        local backOffset = backDir * (FOLLOW_DISTANCE * i)
        local sideOffset = rightDir * (math.sin(phase) * SIDE_AMPLITUDE)
        local upOffset = upDir * (math.cos(phase * 0.8) * UP_AMPLITUDE)

        local pos = HRP.Position + backOffset + sideOffset + upOffset
        local cf = CFrame.new(pos, pos + backDir)

        pcall(function()
            prop.SetCurrentCFrame:InvokeServer(
                prop:GetPivot():Lerp(cf, SMOOTHNESS)
            )
        end)
    end
end)

end

function StopCobra()
if COBRA_CONNECTION then
COBRA_CONNECTION:Disconnect()
COBRA_CONNECTION = nil
end
end

TrollTab:AddToggle({
Name = "Prop Cobra",
Default = false,
Callback = function(v)
COBRA_ENABLED = v
if v then
StartCobra()
else
StopCobra()
end
end
})


--===============================
-- PROP FURACÃO
--===============================

local FURACAO_ENABLED = false
local FURACAO_CONNECTION

local function StartFuracao()
    if FURACAO_CONNECTION then FURACAO_CONNECTION:Disconnect() end

    local t = 0

    FURACAO_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * 4

        for i, prop in ipairs(props) do
            local angle = t + (i * 0.7)

            -- distância varia (afasta e aproxima)
            local radius = 4 + math.sin(t + i) * 3

            -- sobe e desce
            local height = math.cos(t*2 + i) * 4

            -- gira em volta
            local offset = Vector3.new(
                math.cos(angle) * radius,
                height,
                math.sin(angle) * radius
            )

            local pos = HRP.Position + offset
            local look = CFrame.new(pos, HRP.Position)

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(look, 0.35)
                )
            end)
        end
    end)
end

local function StopFuracao()
    if FURACAO_CONNECTION then
        FURACAO_CONNECTION:Disconnect()
        FURACAO_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "props Furacão",
    Default = false,
    Callback = function(v)
        FURACAO_ENABLED = v
        if v then
            StartFuracao()
        else
            StopFuracao()
        end
    end
})


--===============================
-- CÍRCULO MONSTRO NA CINTURA (FIXO E GIGANTE)
--===============================

local WAIST_RING_ENABLED = false
local WAIST_RING_CONNECTION

local function StartWaistRing()
    if WAIST_RING_CONNECTION then WAIST_RING_CONNECTION:Disconnect() end

    local spin = 0

    WAIST_RING_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        spin += dt * 1.5

        local radius = 35      -- TAMANHO MUITO GRANDE (bem longe do corpo)
        local height = -0.5    -- altura fixa da cintura
        local total = #props

        for i, prop in ipairs(props) do
            -- distribuição perfeita e FIXA
            local baseAngle = ((i-1)/total) * math.pi * 2
            local angle = baseAngle + spin

            local offset = Vector3.new(
                math.cos(angle) * radius,
                height,
                math.sin(angle) * radius
            )

            local pos = HRP.Position + offset

            local cf = CFrame.new(pos) * CFrame.Angles(
                0,
                math.rad(angle * 180/math.pi),
                0
            )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.15)
                )
            end)
        end
    end)
end

local function StopWaistRing()
    if WAIST_RING_CONNECTION then
        WAIST_RING_CONNECTION:Disconnect()
        WAIST_RING_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "props Círculo",
    Default = false,
    Callback = function(v)
        WAIST_RING_ENABLED = v
        if v then
            StartWaistRing()
        else
            StopWaistRing()
        end
    end
})


--===============================
-- PROPS CAÓTICOS AO REDOR DE MIM
--===============================

local CHAOS_ENABLED = false
local CHAOS_CONNECTION

local MAX_DISTANCE = 23   -- distância máxima que pode ir pra longe
local BASE_HEIGHT = 0     -- altura base (cintura)
local SPEED = 2.5

local function StartChaosProps()
    if CHAOS_CONNECTION then CHAOS_CONNECTION:Disconnect() end

    local t = 0

    CHAOS_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * SPEED

        for i, prop in ipairs(props) do
            local phase = t + i

            -- movimentos em todas direções
            local side = math.sin(phase * 1.7) * 8
            local forward = math.cos(phase * 1.3) * 8

            -- sobe e desce forte (até +20 e -20)
            local up = math.sin(phase * 2) * 20

            -- vai e volta longe (até 23 studs)
            local distance = (math.sin(phase * 0.8) + 1)/2 * MAX_DISTANCE
            local dir = (HRP.CFrame.LookVector * forward) + (HRP.CFrame.RightVector * side)

            local offset = dir.Unit * distance
            local pos = HRP.Position + offset + Vector3.new(0, BASE_HEIGHT + up, 0)

            -- giro + mortal
            local cf = CFrame.new(pos) *
                CFrame.Angles(
                    math.rad(t*200 + i*40),   -- mortal
                    math.rad(t*180 + i*25),   -- girando
                    math.rad(math.sin(phase)*180)
                )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.25)
                )
            end)
        end
    end)
end

local function StopChaosProps()
    if CHAOS_CONNECTION then
        CHAOS_CONNECTION:Disconnect()
        CHAOS_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "Props caótico",
    Default = false,
    Callback = function(v)
        CHAOS_ENABLED = v
        if v then
            StartChaosProps()
        else
            StopChaosProps()
        end
    end
})


--===============================
-- PROPS ESPALHADOS NO AR (BEM ABERTOS)
--===============================

local AIR_ENABLED = false
local AIR_CONNECTION

local function StartAirSpread()
    if AIR_CONNECTION then AIR_CONNECTION:Disconnect() end

    local t = 0

    AIR_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt

        for i, prop in ipairs(props) do
            -- ALTURA fixa ~25m
            local height = 30 + math.sin(t + i) * 3

            -- ESPALHAMENTO MUITO MAIOR
            local angle = (i * 2.5)
            local radius = 12 + (i * 2)   -- bem mais longe um do outro

            local offset = Vector3.new(
                math.cos(angle) * radius,
                height,
                math.sin(angle) * radius
            )

            local pos = HRP.Position + offset

            local cf = CFrame.new(pos) * CFrame.Angles(
                math.rad((t*50 + i*30) % 360),
                math.rad((t*35 + i*20) % 360),
                0
            )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.30)
                )
            end)
        end
    end)
end

local function StopAirSpread()
    if AIR_CONNECTION then
        AIR_CONNECTION:Disconnect()
        AIR_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "Props strela",
    Default = false,
    Callback = function(v)
        AIR_ENABLED = v
        if v then
            StartAirSpread()
        else
            StopAirSpread()
        end
    end
})



--===============================
-- CÍRCULO VERTICAL NA FRENTE (TIPO PORTAL)
--===============================

local FRONT_CIRCLE_ENABLED = false
local FRONT_CIRCLE_CONNECTION

local function StartFrontCircle()
    if FRONT_CIRCLE_CONNECTION then FRONT_CIRCLE_CONNECTION:Disconnect() end

    local t = 0

    FRONT_CIRCLE_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * 1.8

        -- posição do "portal" na frente
        local center = HRP.Position + HRP.CFrame.LookVector * 8 + Vector3.new(0, 2, 0)

        local total = #props
        local radius = 6 -- MAIS ESPAÇADO

        for i, prop in ipairs(props) do
            local angle = ((i-1)/total) * math.pi * 2
            local spin = t

            -- círculo VERTICAL (altura + lateral)
            local side = math.cos(angle + spin) * radius
            local up = math.sin(angle + spin) * radius

            local pos =
                center
                + HRP.CFrame.RightVector * side
                + Vector3.new(0, up, 0)

            local cf = CFrame.new(pos) * CFrame.Angles(
                math.rad(up * 5),
                math.rad((angle+spin)*180/math.pi),
                0
            )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.25)
                )
            end)
        end
    end)
end

local function StopFrontCircle()
    if FRONT_CIRCLE_CONNECTION then
        FRONT_CIRCLE_CONNECTION:Disconnect()
        FRONT_CIRCLE_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "próp portal",
    Default = false,
    Callback = function(v)
        FRONT_CIRCLE_ENABLED = v
        if v then
            StartFrontCircle()
        else
            StopFrontCircle()
        end
    end
})


TrollTab:AddSection({"props no player selecionado"})


--===============================
-- PROPS NO PLAYER SELECIONADO
--===============================

local TARGET_ENABLED = false
local TARGET_CONNECTION
local SentProps = {}

local function getTargetPlayer()
    if not selectedPlayer then return nil end
    return Players:FindFirstChild(selectedPlayer)
end

local function StartSelectedTarget()
    if TARGET_CONNECTION then TARGET_CONNECTION:Disconnect() end

    local t = 0

    TARGET_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local target = getTargetPlayer()
        if not target or not target.Character then return end

        local root = target.Character:FindFirstChild("HumanoidRootPart")
        local hum = target.Character:FindFirstChild("Humanoid")
        if not root or not hum then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * 3

        for i, prop in ipairs(props) do

            -- SENTOU → sobe MUITO ALTO
            if hum.Sit then
                if not SentProps[prop] then
                    SentProps[prop] = true

                    local upPos = Vector3.new(
                        root.Position.X,
                        1000000, -- muito alto
                        root.Position.Z
                    )

                    pcall(function()
                        prop.SetCurrentCFrame:InvokeServer(CFrame.new(upPos))
                    end)
                end
                continue
            end

            -- LEVANTOU → volta pra você
            if SentProps[prop] then
                SentProps[prop] = nil

                local backPos = HRP.Position + Vector3.new(
                    math.cos(i)*4,
                    3,
                    math.sin(i)*4
                )

                pcall(function()
                    prop.SetCurrentCFrame:InvokeServer(CFrame.new(backPos))
                end)
                continue
            end

            -- MOVIMENTO LOUCO EM VOLTA DO PLAYER
            local move = Vector3.new(
                math.cos(t + i) * 3,
                math.sin(t*2 + i) * 2,
                math.sin(t + i*2) * 3
            )

            local cf = root.CFrame * CFrame.new(move) *
                CFrame.Angles(
                    math.rad(math.sin(t*4+i)*180),
                    math.rad(t*200),
                    math.rad(math.cos(t*3+i)*180)
                )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.35)
                )
            end)
        end
    end)
end

local function StopSelectedTarget()
    if TARGET_CONNECTION then
        TARGET_CONNECTION:Disconnect()
        TARGET_CONNECTION = nil
    end
    SentProps = {}
end

TrollTab:AddToggle({
    Name = "fling player",
    Default = false,
    Callback = function(v)
        TARGET_ENABLED = v
        if v then
            StartSelectedTarget()
        else
            StopSelectedTarget()
        end
    end
})



--===============================
-- PLAYER SELECIONADO (SENTOU = DESCE)
--===============================

local TARGET_ENABLED = false
local TARGET_CONNECTION
local SentProps = {}

local function getTargetPlayer()
    if not selectedPlayer then return nil end
    return Players:FindFirstChild(selectedPlayer)
end

local function StartSelectedTarget()
    if TARGET_CONNECTION then TARGET_CONNECTION:Disconnect() end

    local t = 0

    TARGET_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local target = getTargetPlayer()
        if not target or not target.Character then return end

        local root = target.Character:FindFirstChild("HumanoidRootPart")
        local hum = target.Character:FindFirstChild("Humanoid")
        if not root or not hum then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * 3

        for i, prop in ipairs(props) do

            -- SENTOU → vai pra -460
            if hum.Sit then
                if not SentProps[prop] then
                    SentProps[prop] = true

                    local downPos = Vector3.new(
                        root.Position.X,
                        -460,
                        root.Position.Z
                    )

                    pcall(function()
                        prop.SetCurrentCFrame:InvokeServer(CFrame.new(downPos))
                    end)
                end
                continue
            end

            -- LEVANTOU → volta pra você
            if SentProps[prop] then
                SentProps[prop] = nil

                local backPos = HRP.Position + Vector3.new(
                    math.cos(i)*4,
                    3,
                    math.sin(i)*4
                )

                pcall(function()
                    prop.SetCurrentCFrame:InvokeServer(CFrame.new(backPos))
                end)
                continue
            end

            -- MOVIMENTO EM VOLTA DO PLAYER
            local move = Vector3.new(
                math.cos(t + i) * 3,
                math.sin(t*2 + i) * 2,
                math.sin(t + i*2) * 3
            )

            local cf = root.CFrame * CFrame.new(move) *
                CFrame.Angles(
                    math.rad(math.sin(t*4+i)*180),
                    math.rad(t*200),
                    math.rad(math.cos(t*3+i)*180)
                )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.35)
                )
            end)
        end
    end)
end

local function StopSelectedTarget()
    if TARGET_CONNECTION then
        TARGET_CONNECTION:Disconnect()
        TARGET_CONNECTION = nil
    end
    SentProps = {}
end

TrollTab:AddToggle({
    Name = "kill player",
    Default = false,
    Callback = function(v)
        TARGET_ENABLED = v
        if v then
            StartSelectedTarget()
        else
            StopSelectedTarget()
        end
    end
})


--===============================
-- CÍRCULO PERFEITO NO CHÃO (COM BURACO REAL)
--===============================

local RING_ENABLED = false
local RING_CONNECTION

local function getTargetPlayer()
    if not selectedPlayer then return nil end
    return Players:FindFirstChild(selectedPlayer)
end

local function StartRing()
    if RING_CONNECTION then RING_CONNECTION:Disconnect() end

    local t = 0

    RING_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        if not Character or not HRP or not Humanoid or Humanoid.Health <= 0 then return end

        local target = getTargetPlayer()
        if not target or not target.Character then return end

        local root = target.Character:FindFirstChild("HumanoidRootPart")
        if not root then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * 1.8

        local radius = 8
        local total = #props

        -- tamanho do buraco em graus (ex: 70° vazio)
        local gapAngle = math.rad(70)
        local usableAngle = (math.pi * 2) - gapAngle

        for i, prop in ipairs(props) do
            -- distribui TODOS dentro da parte que sobra do círculo
            local percent = (i-1) / total
            local angle = percent * usableAngle

            local spin = t
            local finalAngle = angle + spin

            local x = math.cos(finalAngle) * radius
            local z = math.sin(finalAngle) * radius

            local pos = root.Position + Vector3.new(x, -2.7, z)

            local cf = CFrame.new(pos) * CFrame.Angles(
                0,
                math.rad((finalAngle) * 180/math.pi),
                0
            )

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, 0.28)
                )
            end)
        end
    end)
end

local function StopRing()
    if RING_CONNECTION then
        RING_CONNECTION:Disconnect()
        RING_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "próp círculo",
    Default = false,
    Callback = function(v)
        RING_ENABLED = v
        if v then
            StartRing()
        else
            StopRing()
        end
    end
})



--===============================
-- PROP COBRA (PLAYER SELECIONADO) - SEM CONFLITO
--===============================

local COBRA_CONNECTION
local COBRA_ACTIVE = false

local FOLLOW_DISTANCE = 3.5
local SIDE_AMPLITUDE = 3.2
local UP_AMPLITUDE = 1.2
local WAVE_SPEED = 10
local PHASE_OFFSET = 1.1
local SMOOTHNESS = 0.35

local function getTargetPlayer()
    if not selectedPlayer then return nil end
    return Players:FindFirstChild(selectedPlayer)
end

local function stopAllPropModes()
    if COBRA_CONNECTION then
        COBRA_CONNECTION:Disconnect()
        COBRA_CONNECTION = nil
    end
end

local function StartCobraTarget()
    stopAllPropModes()

    local t = 0

    COBRA_CONNECTION = RunService.Heartbeat:Connect(function(dt)
        local target = getTargetPlayer()
        if not target or not target.Character then return end

        local root = target.Character:FindFirstChild("HumanoidRootPart")
        local hum = target.Character:FindFirstChild("Humanoid")
        if not root or not hum or hum.Health <= 0 then return end

        local props = GetMyPropsRaid()
        if #props == 0 then return end

        t += dt * WAVE_SPEED

        for i, prop in ipairs(props) do
            local phase = t - i * PHASE_OFFSET

            local backDir = -root.CFrame.LookVector
            local rightDir = root.CFrame.RightVector
            local upDir = Vector3.new(0,1,0)

            local backOffset = backDir * (FOLLOW_DISTANCE * i)
            local sideOffset = rightDir * (math.sin(phase) * SIDE_AMPLITUDE)
            local upOffset = upDir * (math.cos(phase * 0.8) * UP_AMPLITUDE)

            local pos = root.Position + backOffset + sideOffset + upOffset
            local cf = CFrame.new(pos, pos + backDir)

            pcall(function()
                prop.SetCurrentCFrame:InvokeServer(
                    prop:GetPivot():Lerp(cf, SMOOTHNESS)
                )
            end)
        end
    end)
end

local function StopCobraTarget()
    if COBRA_CONNECTION then
        COBRA_CONNECTION:Disconnect()
        COBRA_CONNECTION = nil
    end
end

TrollTab:AddToggle({
    Name = "Prop Cobra player",
    Default = false,
    Callback = function(v)
        COBRA_ACTIVE = v
        if v then
            StartCobraTarget()
        else
            StopCobraTarget()
        end
    end
})



